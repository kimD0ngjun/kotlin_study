# 코루틴 vs 가상 스레드
[참조 링크](https://huisam.tistory.com/entry/virtual-thread-and-kotlin-coroutine?category=705896)
## 1. 개요
### 1) 왜 코틀린을 공부하려는가?
- 새길을 구현할 당시, 순수 자바로만 구현하였음
- 모놀리식 아키텍처 내에서 **수집**과 **소비**라는 두 개의 프로세스를 동시 구현해야 했고, 자연스럽게 멀티 스레드를 떠올림
- 자바 21의 가상 스레드를 적극 활용하였고 결과적으로 잘 동작함(지금도 AWS에서 돈 빠져나가는 중...)
- 가상 스레드의 목적은 동시성 극대화를 통한 네트워크 입출력 작업 효율성 확보였는데... **사실 당시에는 IO 작업이니 비동기 논블로킹을 생각했으나, 구조상 한계가 있어 동기 블로킹 로직에서 동시성을 극대화하는 방향**으로 생각
- 그러다가 코틀린의 코루틴을 알게 되고, 코틀린으로 역량 확장할 겸 + **코루틴으로 로직을 대체하면, 비동기 논블로킹 구현이 가능하지 않을까**라는 생각으로 발전
### 2) 내 리팩토링 아이디어가 적합할까?
- 코틀린 쬐끔 찍먹해보면서 우선 든 생각은, **코루틴과 가상 스레드를 동일 선상에서 비교하면 안 된다**
- 얼마나 효율적인지는 아직 모른다. 오히려 비효율적일 수도 있다. 
- 하지만 동기 블로킹에서 동시성을 극대화한 로직을 비동기 논블로킹으로 리팩토링한다는 점 때문에 **무조건 성능상 이점이다라는 생각은 오판**일듯
- 그렇다면 데이터 수집 로직을 가상 스레드풀에 할당한 로직이 동시성이 극대화된 동기 블로킹 로직이라는 것과, 이를 비동기 논블로킹으로 리팩토링하는 것, 이 두 개는 옳을까?
### 3) 내가 하려는 것은 수집 프로세스의 섬세한 폴백
- 솔직히 폴백을 구현했다지만, 단순 재시도 정도에 불과하고 수집기를 완벽히 제어하지 못함. 수집기를 제어하고 감시하기 위한 또다른 스레드가 필요함
- 병렬성이 확보됐지만 아직 챙기지 못한 **데이터 수집 프로세스의 흐름 제어(폴백, 중단, 재시도, 취소)를 세밀하게 챙길 수 있는 수단으로써 코루틴을 생각**
- 즉, 단순한 성능 개선의 시선으로 접근하는 게 아니라 아키텍처 제어 확장의 시선으로 바라보는 게 맞을듯